using System;
using VWeaponEditor.Avalonia.MemoryUtils;

namespace VWeaponEditor.Avalonia {
    public static unsafe class WeaponInfo {
        public static unsafe uint m_name(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x0010);
        public static unsafe void m_name(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x0010, value);
        public static unsafe uint m_model(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x0014);
        public static unsafe void m_model(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x0014, value);
        public static unsafe uint m_audio(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x0018);
        public static unsafe void m_audio(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x0018, value);
        public static unsafe uint m_slot(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x001C);
        public static unsafe void m_slot(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x001C, value);
        public static unsafe eDamageType damage_type(byte* pWeaponInfo) => *(eDamageType*) (pWeaponInfo + 0x0020);
        public static unsafe void damage_type(Mem64 mem, IntPtr addr, eDamageType value) => mem.Write(addr + 0x0020, value);
        public static unsafe eFireType fire_type(byte* pWeaponInfo) => *(eFireType*) (pWeaponInfo + 0x0054);
        public static unsafe void fire_type(Mem64 mem, IntPtr addr, eFireType value) => mem.Write(addr + 0x0054, value);
        public static unsafe eWeaponWheelSlot wheel_slot(byte* pWeaponInfo) => *(eWeaponWheelSlot*) (pWeaponInfo + 0x0058);
        public static unsafe void wheel_slot(Mem64 mem, IntPtr addr, eWeaponWheelSlot value) => mem.Write(addr + 0x0058, value);
        public static unsafe uint group(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x005C);
        public static unsafe void group(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x005C, value);
        public static unsafe uint clip_size(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x0070);
        public static unsafe void clip_size(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x0070, value);
        public static unsafe float accuracy_spread(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0074);
        public static unsafe void accuracy_spread(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0074, value);
        public static unsafe float accurate_mode_accuracy_modifier(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0078);
        public static unsafe void accurate_mode_accuracy_modifier(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0078, value);
        public static unsafe float run_and_gun_accuracy(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x007C);
        public static unsafe void run_and_gun_accuracy(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x007C, value);
        public static unsafe float run_and_gun_min_accuracy(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0080);
        public static unsafe void run_and_gun_min_accuracy(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0080, value);
        public static unsafe float recoil_accuracy_max(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0084);
        public static unsafe void recoil_accuracy_max(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0084, value);
        public static unsafe float recoil_error_time(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0088);
        public static unsafe void recoil_error_time(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0088, value);
        public static unsafe float recoil_recovery_rate(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x008C);
        public static unsafe void recoil_recovery_rate(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x008C, value);
        public static unsafe float recoil_accuracy_to_allow_headshot_ai(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0090);
        public static unsafe void recoil_accuracy_to_allow_headshot_ai(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0090, value);
        public static unsafe float min_headshot_distance_ai(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0094);
        public static unsafe void min_headshot_distance_ai(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0094, value);
        public static unsafe float max_headshot_distance_ai(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0098);
        public static unsafe void max_headshot_distance_ai(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0098, value);
        public static unsafe float headshot_damage_modifier_ai(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x009C);
        public static unsafe void headshot_damage_modifier_ai(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x009C, value);
        public static unsafe float recoil_accuracy_to_allow_headshot_player(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x00A0);
        public static unsafe void recoil_accuracy_to_allow_headshot_player(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x00A0, value);
        public static unsafe float min_headshot_distance_player(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x00A4);
        public static unsafe void min_headshot_distance_player(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x00A4, value);
        public static unsafe float max_headshot_distance_player(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x00A8);
        public static unsafe void max_headshot_distance_player(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x00A8, value);
        public static unsafe float headshot_damage_modifier_player(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x00AC);
        public static unsafe void headshot_damage_modifier_player(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x00AC, value);
        public static unsafe float damage(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x00B0);
        public static unsafe void damage(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x00B0, value);
        public static unsafe float damage_time(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x00B4);
        public static unsafe void damage_time(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x00B4, value);
        public static unsafe float damage_time_in_vehicle(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x00B8);
        public static unsafe void damage_time_in_vehicle(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x00B8, value);
        public static unsafe float damage_time_in_vehicle_headshot(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x00BC);
        public static unsafe void damage_time_in_vehicle_headshot(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x00BC, value);
        public static unsafe float endurance_damage(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x00C0);
        public static unsafe void endurance_damage(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x00C0, value);
        public static unsafe uint N00000898(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x00C4);
        public static unsafe void N00000898(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x00C4, value);
        public static unsafe float hit_limbs_damage_modifier(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x00C8);
        public static unsafe void hit_limbs_damage_modifier(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x00C8, value);
        public static unsafe float network_hit_limbs_damage_modifier(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x00CC);
        public static unsafe void network_hit_limbs_damage_modifier(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x00CC, value);
        public static unsafe float lightly_armoured_damage_modifier(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x00D0);
        public static unsafe void lightly_armoured_damage_modifier(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x00D0, value);
        public static unsafe float vehicle_damage_modifier(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x00D4);
        public static unsafe void vehicle_damage_modifier(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x00D4, value);
        public static unsafe float force(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x00D8);
        public static unsafe void force(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x00D8, value);
        public static unsafe float force_on_ped(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x00DC);
        public static unsafe void force_on_ped(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x00DC, value);
        public static unsafe float force_on_vehicle(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x00E0);
        public static unsafe void force_on_vehicle(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x00E0, value);
        public static unsafe float force_on_heli(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x00E4);
        public static unsafe void force_on_heli(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x00E4, value);
        public static unsafe float force_max_strength_mult(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x00F8);
        public static unsafe void force_max_strength_mult(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x00F8, value);
        public static unsafe float force_falloff_range_start(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x00FC);
        public static unsafe void force_falloff_range_start(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x00FC, value);
        public static unsafe float force_falloff_range_end(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0100);
        public static unsafe void force_falloff_range_end(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0100, value);
        public static unsafe float force_falloff_range_min(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0104);
        public static unsafe void force_falloff_range_min(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0104, value);
        public static unsafe float project_force(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0108);
        public static unsafe void project_force(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0108, value);
        public static unsafe float frag_impulse(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x010C);
        public static unsafe void frag_impulse(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x010C, value);
        public static unsafe float penetration(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0110);
        public static unsafe void penetration(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0110, value);
        public static unsafe float vertical_launch_adjustment(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0114);
        public static unsafe void vertical_launch_adjustment(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0114, value);
        public static unsafe float drop_forward_velocity(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0118);
        public static unsafe void drop_forward_velocity(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0118, value);
        public static unsafe float speed(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x011C);
        public static unsafe void speed(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x011C, value);
        public static unsafe uint bullets_in_batch(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x0120);
        public static unsafe void bullets_in_batch(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x0120, value);
        public static unsafe float batch_spread(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0124);
        public static unsafe void batch_spread(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0124, value);
        public static unsafe float reload_time_mp(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0128);
        public static unsafe void reload_time_mp(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0128, value);
        public static unsafe float reload_time_sp(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x012C);
        public static unsafe void reload_time_sp(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x012C, value);
        public static unsafe float vehicle_reload_time(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0130);
        public static unsafe void vehicle_reload_time(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0130, value);
        public static unsafe float anim_reload_time(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0134);
        public static unsafe void anim_reload_time(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0134, value);
        public static unsafe int bullets_per_anime_loop(byte* pWeaponInfo) => *(int*) (pWeaponInfo + 0x0138);
        public static unsafe void bullets_per_anime_loop(Mem64 mem, IntPtr addr, int value) => mem.Write(addr + 0x0138, value);
        public static unsafe float time_between_shots(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x013C);
        public static unsafe void time_between_shots(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x013C, value);
        public static unsafe float time_left_between_shots_where_should_fire_is_cached(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0140);
        public static unsafe void time_left_between_shots_where_should_fire_is_cached(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0140, value);
        public static unsafe float spinup_time(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0144);
        public static unsafe void spinup_time(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0144, value);
        public static unsafe float spin_time(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0148);
        public static unsafe void spin_time(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0148, value);
        public static unsafe float spindown_time(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x014C);
        public static unsafe void spindown_time(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x014C, value);
        public static unsafe float alternate_wait_time(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0150);
        public static unsafe void alternate_wait_time(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0150, value);
        public static unsafe float bullet_bending_near_radius(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0154);
        public static unsafe void bullet_bending_near_radius(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0154, value);
        public static unsafe float bullet_bending_far_radius(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0158);
        public static unsafe void bullet_bending_far_radius(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0158, value);
        public static unsafe float bullet_bending_zoom_radius(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x015C);
        public static unsafe void bullet_bending_zoom_radius(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x015C, value);
        public static unsafe float first_person_bullet_bending_near_radius(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0160);
        public static unsafe void first_person_bullet_bending_near_radius(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0160, value);
        public static unsafe float first_person_bullet_bending_far_radius(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0164);
        public static unsafe void first_person_bullet_bending_far_radius(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0164, value);
        public static unsafe float first_person_bullet_bending_zoom_radius(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0168);
        public static unsafe void first_person_bullet_bending_zoom_radius(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0168, value);
        public static unsafe sWeaponFx weapon_fx(byte* pWeaponInfo) => *(sWeaponFx*) (pWeaponInfo + 0x0170);
        public static unsafe void weapon_fx(Mem64 mem, IntPtr addr, sWeaponFx value) => mem.Write(addr + 0x0170, value);
        public static unsafe int initial_rumble_duration(byte* pWeaponInfo) => *(int*) (pWeaponInfo + 0x0250);
        public static unsafe void initial_rumble_duration(Mem64 mem, IntPtr addr, int value) => mem.Write(addr + 0x0250, value);
        public static unsafe float initial_rumble_intensity(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0254);
        public static unsafe void initial_rumble_intensity(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0254, value);
        public static unsafe float initial_rumble_intensity_trigger(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0258);
        public static unsafe void initial_rumble_intensity_trigger(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0258, value);
        public static unsafe int rumble_duration(byte* pWeaponInfo) => *(int*) (pWeaponInfo + 0x025C);
        public static unsafe void rumble_duration(Mem64 mem, IntPtr addr, int value) => mem.Write(addr + 0x025C, value);
        public static unsafe float rumble_intensity(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0260);
        public static unsafe void rumble_intensity(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0260, value);
        public static unsafe float rumble_intensity_trigger(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0264);
        public static unsafe void rumble_intensity_trigger(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0264, value);
        public static unsafe float rumble_damage_intensity(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0268);
        public static unsafe void rumble_damage_intensity(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0268, value);
        public static unsafe int initial_rumble_duration_fps(byte* pWeaponInfo) => *(int*) (pWeaponInfo + 0x026C);
        public static unsafe void initial_rumble_duration_fps(Mem64 mem, IntPtr addr, int value) => mem.Write(addr + 0x026C, value);
        public static unsafe float initial_rumble_intensity_fps(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0270);
        public static unsafe void initial_rumble_intensity_fps(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0270, value);
        public static unsafe int rumble_duration_fps(byte* pWeaponInfo) => *(int*) (pWeaponInfo + 0x0274);
        public static unsafe void rumble_duration_fps(Mem64 mem, IntPtr addr, int value) => mem.Write(addr + 0x0274, value);
        public static unsafe float rumble_intensity_fps(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0278);
        public static unsafe void rumble_intensity_fps(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0278, value);
        public static unsafe float network_player_damage_modifier(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x027C);
        public static unsafe void network_player_damage_modifier(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x027C, value);
        public static unsafe float network_ped_damage_modifier(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0280);
        public static unsafe void network_ped_damage_modifier(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0280, value);
        public static unsafe float network_headshot_modifier(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0284);
        public static unsafe void network_headshot_modifier(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0284, value);
        public static unsafe float lock_on_range(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0288);
        public static unsafe void lock_on_range(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0288, value);
        public static unsafe float weapon_range(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x028C);
        public static unsafe void weapon_range(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x028C, value);
        public static unsafe float ai_sound_range(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0290);
        public static unsafe void ai_sound_range(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0290, value);
        public static unsafe float ai_potential_blast_event_range(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0294);
        public static unsafe void ai_potential_blast_event_range(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0294, value);
        public static unsafe float damage_fall_off_range_min(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0298);
        public static unsafe void damage_fall_off_range_min(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0298, value);
        public static unsafe float damage_fall_off_range_max(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x029C);
        public static unsafe void damage_fall_off_range_max(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x029C, value);
        public static unsafe float damage_fall_off_modifier(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x02A8);
        public static unsafe void damage_fall_off_modifier(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x02A8, value);
        public static unsafe uint vehicle_weapon_hash(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x02B4);
        public static unsafe void vehicle_weapon_hash(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x02B4, value);
        public static unsafe uint default_camera_hash(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x02B8);
        public static unsafe void default_camera_hash(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x02B8, value);
        public static unsafe uint aim_camera_hash(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x02BC);
        public static unsafe void aim_camera_hash(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x02BC, value);
        public static unsafe uint fire_camera_hash(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x02C0);
        public static unsafe void fire_camera_hash(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x02C0, value);
        public static unsafe uint cover_camera_hash(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x02C4);
        public static unsafe void cover_camera_hash(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x02C4, value);
        public static unsafe uint cover_ready_to_fire_hash(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x02C8);
        public static unsafe void cover_ready_to_fire_hash(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x02C8, value);
        public static unsafe uint run_and_gun_camera_hash(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x02CC);
        public static unsafe void run_and_gun_camera_hash(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x02CC, value);
        public static unsafe uint cinematic_shooting_camera_hash(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x02D0);
        public static unsafe void cinematic_shooting_camera_hash(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x02D0, value);
        public static unsafe uint alt_or_scoped_camera_hash(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x02D4);
        public static unsafe void alt_or_scoped_camera_hash(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x02D4, value);
        public static unsafe uint run_and_gun_alt_or_scoped_camera_hash(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x02D8);
        public static unsafe void run_and_gun_alt_or_scoped_camera_hash(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x02D8, value);
        public static unsafe uint cinematic_shooting_alt_or_scoped_camera_hash(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x02DC);
        public static unsafe void cinematic_shooting_alt_or_scoped_camera_hash(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x02DC, value);
        public static unsafe uint pov_turret_camera_hash(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x02E0);
        public static unsafe void pov_turret_camera_hash(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x02E0, value);
        public static unsafe uint recoil_shake_hash(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x02E4);
        public static unsafe void recoil_shake_hash(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x02E4, value);
        public static unsafe uint recoil_shake_hash_first_person(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x02E8);
        public static unsafe void recoil_shake_hash_first_person(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x02E8, value);
        public static unsafe uint accuracy_offset_shake_hash(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x02EC);
        public static unsafe void accuracy_offset_shake_hash(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x02EC, value);
        public static unsafe float min_time_between_recoil_shakes(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x02F0);
        public static unsafe void min_time_between_recoil_shakes(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x02F0, value);
        public static unsafe float recoil_shake_amplitude(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x02F4);
        public static unsafe void recoil_shake_amplitude(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x02F4, value);
        public static unsafe float explosion_shake_amplitude(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x02F8);
        public static unsafe void explosion_shake_amplitude(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x02F8, value);
        public static unsafe float camera_fov(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x02FC);
        public static unsafe void camera_fov(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x02FC, value);
        public static unsafe float first_person_aim_fov_min(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0300);
        public static unsafe void first_person_aim_fov_min(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0300, value);
        public static unsafe float first_person_aim_fov_max(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0304);
        public static unsafe void first_person_aim_fov_max(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0304, value);
        public static unsafe float first_person_scope_fov(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0308);
        public static unsafe void first_person_scope_fov(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0308, value);
        public static unsafe float first_person_scope_attachment_fov(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x030C);
        public static unsafe void first_person_scope_attachment_fov(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x030C, value);
        public static unsafe Vector3f first_person_driveby_ik_offset(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x0310);
        public static unsafe void first_person_driveby_ik_offset(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x0310, value);
        public static unsafe Vector3f first_person_rng_offset(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x0320);
        public static unsafe void first_person_rng_offset(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x0320, value);
        public static unsafe Vector3f first_person_rng_rotation_offset(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x0330);
        public static unsafe void first_person_rng_rotation_offset(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x0330, value);
        public static unsafe Vector3f first_person_lt_offset(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x0340);
        public static unsafe void first_person_lt_offset(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x0340, value);
        public static unsafe Vector3f first_person_lt_rotation_offset(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x0350);
        public static unsafe void first_person_lt_rotation_offset(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x0350, value);
        public static unsafe Vector3f first_person_scope_offset(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x0360);
        public static unsafe void first_person_scope_offset(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x0360, value);
        public static unsafe Vector3f first_person_scope_attachment_offset(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x0370);
        public static unsafe void first_person_scope_attachment_offset(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x0370, value);
        public static unsafe Vector3f first_person_scope_rotation_offset(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x0380);
        public static unsafe void first_person_scope_rotation_offset(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x0380, value);
        public static unsafe Vector3f first_person_scope_attachment_rotation_offset(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x0390);
        public static unsafe void first_person_scope_attachment_rotation_offset(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x0390, value);
        public static unsafe Vector3f first_person_as_third_person_idle_offset(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x03A0);
        public static unsafe void first_person_as_third_person_idle_offset(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x03A0, value);
        public static unsafe Vector3f first_person_as_third_person_rng_offset(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x03B0);
        public static unsafe void first_person_as_third_person_rng_offset(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x03B0, value);
        public static unsafe Vector3f first_person_as_third_person_lt_offset(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x03C0);
        public static unsafe void first_person_as_third_person_lt_offset(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x03C0, value);
        public static unsafe Vector3f first_person_as_third_person_scope_offset(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x03D0);
        public static unsafe void first_person_as_third_person_scope_offset(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x03D0, value);
        public static unsafe Vector3f first_person_as_third_person_weapon_blocked_offset(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x03E0);
        public static unsafe void first_person_as_third_person_weapon_blocked_offset(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x03E0, value);
        public static unsafe float first_person_dof_subject_magnification_power_factor_near(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x03F0);
        public static unsafe void first_person_dof_subject_magnification_power_factor_near(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x03F0, value);
        public static unsafe float first_person_dof_max_near_in_focus_distance(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x03F4);
        public static unsafe void first_person_dof_max_near_in_focus_distance(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x03F4, value);
        public static unsafe float first_person_dof_max_near_in_focus_distance_blend_level(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x03F8);
        public static unsafe void first_person_dof_max_near_in_focus_distance_blend_level(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x03F8, value);
        public static unsafe float zoom_factor_for_accurate_mode(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0410);
        public static unsafe void zoom_factor_for_accurate_mode(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0410, value);
        public static unsafe Vector3f aim_offset_min(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x0420);
        public static unsafe void aim_offset_min(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x0420, value);
        public static unsafe Vector3f aim_offset_max(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x0430);
        public static unsafe void aim_offset_max(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x0430, value);
        public static unsafe Vector2f torso_aim_offset(byte* pWeaponInfo) => *(Vector2f*) (pWeaponInfo + 0x0440);
        public static unsafe void torso_aim_offset(Mem64 mem, IntPtr addr, Vector2f value) => mem.Write(addr + 0x0440, value);
        public static unsafe Vector2f torso_crouched_aim_offset(byte* pWeaponInfo) => *(Vector2f*) (pWeaponInfo + 0x0448);
        public static unsafe void torso_crouched_aim_offset(Mem64 mem, IntPtr addr, Vector2f value) => mem.Write(addr + 0x0448, value);
        public static unsafe float aim_probe_length_min(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0450);
        public static unsafe void aim_probe_length_min(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0450, value);
        public static unsafe float aim_probe_length_max(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0454);
        public static unsafe void aim_probe_length_max(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0454, value);
        public static unsafe Vector3f aim_offset_min_fps_idle(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x0460);
        public static unsafe void aim_offset_min_fps_idle(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x0460, value);
        public static unsafe Vector3f aim_offset_med_fps_idle(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x0470);
        public static unsafe void aim_offset_med_fps_idle(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x0470, value);
        public static unsafe Vector3f aim_offset_max_fps_idle(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x0480);
        public static unsafe void aim_offset_max_fps_idle(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x0480, value);
        public static unsafe Vector3f aim_offset_min_fps_lt(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x0490);
        public static unsafe void aim_offset_min_fps_lt(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x0490, value);
        public static unsafe Vector3f aim_offset_max_fps_lt(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x04A0);
        public static unsafe void aim_offset_max_fps_lt(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x04A0, value);
        public static unsafe Vector3f aim_offset_min_fps_rng(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x04B0);
        public static unsafe void aim_offset_min_fps_rng(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x04B0, value);
        public static unsafe Vector3f aim_offset_max_fps_rng(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x04C0);
        public static unsafe void aim_offset_max_fps_rng(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x04C0, value);
        public static unsafe Vector3f aim_offset_min_fps_scope(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x04D0);
        public static unsafe void aim_offset_min_fps_scope(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x04D0, value);
        public static unsafe Vector3f aim_offset_max_fps_scope(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x04E0);
        public static unsafe void aim_offset_max_fps_scope(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x04E0, value);
        public static unsafe Vector3f aim_offset_end_pos_min_fps_idle(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x04F0);
        public static unsafe void aim_offset_end_pos_min_fps_idle(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x04F0, value);
        public static unsafe Vector3f aim_offset_end_pos_med_fps_idle(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x0500);
        public static unsafe void aim_offset_end_pos_med_fps_idle(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x0500, value);
        public static unsafe Vector3f aim_offset_end_pos_max_fps_idle(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x0510);
        public static unsafe void aim_offset_end_pos_max_fps_idle(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x0510, value);
        public static unsafe Vector3f aim_offset_end_pos_min_fps_lt(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x0520);
        public static unsafe void aim_offset_end_pos_min_fps_lt(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x0520, value);
        public static unsafe Vector3f aim_offset_end_pos_med_fps_lt(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x0530);
        public static unsafe void aim_offset_end_pos_med_fps_lt(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x0530, value);
        public static unsafe Vector3f aim_offset_end_pos_max_fps_lt(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x0540);
        public static unsafe void aim_offset_end_pos_max_fps_lt(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x0540, value);
        public static unsafe float aim_probe_radius_override_fps_idle(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0550);
        public static unsafe void aim_probe_radius_override_fps_idle(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0550, value);
        public static unsafe float aim_probe_radius_override_fps_idle_stealth(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0554);
        public static unsafe void aim_probe_radius_override_fps_idle_stealth(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0554, value);
        public static unsafe float aim_probe_radius_override_fps_lt(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0558);
        public static unsafe void aim_probe_radius_override_fps_lt(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0558, value);
        public static unsafe float aim_probe_radius_override_fps_rng(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x055C);
        public static unsafe void aim_probe_radius_override_fps_rng(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x055C, value);
        public static unsafe float aim_probe_radius_override_fps_scope(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0560);
        public static unsafe void aim_probe_radius_override_fps_scope(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0560, value);
        public static unsafe Vector3f left_hand_ik_offset(byte* pWeaponInfo) => *(Vector3f*) (pWeaponInfo + 0x0570);
        public static unsafe void left_hand_ik_offset(Mem64 mem, IntPtr addr, Vector3f value) => mem.Write(addr + 0x0570, value);
        public static unsafe float ik_recoil_displacement(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0580);
        public static unsafe void ik_recoil_displacement(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0580, value);
        public static unsafe float ik_recoil_displacement_scope(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0584);
        public static unsafe void ik_recoil_displacement_scope(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0584, value);
        public static unsafe float ik_recoil_displacement_scale_backward(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0588);
        public static unsafe void ik_recoil_displacement_scale_backward(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0588, value);
        public static unsafe float ik_recoil_displacement_scale_vertical(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x058C);
        public static unsafe void ik_recoil_displacement_scale_vertical(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x058C, value);
        public static unsafe Vector2f reticule_hud_position(byte* pWeaponInfo) => *(Vector2f*) (pWeaponInfo + 0x0590);
        public static unsafe void reticule_hud_position(Mem64 mem, IntPtr addr, Vector2f value) => mem.Write(addr + 0x0590, value);
        public static unsafe Vector2f reticule_hud_position_pov_turret(byte* pWeaponInfo) => *(Vector2f*) (pWeaponInfo + 0x0598);
        public static unsafe void reticule_hud_position_pov_turret(Mem64 mem, IntPtr addr, Vector2f value) => mem.Write(addr + 0x0598, value);
        public static unsafe float reticule_min_size_standing(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x05A0);
        public static unsafe void reticule_min_size_standing(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x05A0, value);
        public static unsafe float reticule_min_size_crouched(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x05A4);
        public static unsafe void reticule_min_size_crouched(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x05A4, value);
        public static unsafe float reticule_scale(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x05A8);
        public static unsafe void reticule_scale(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x05A8, value);
        public static unsafe uint reticule_style_hash(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x05AC);
        public static unsafe void reticule_style_hash(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x05AC, value);
        public static unsafe uint first_person_reticule_style_hash(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x05B0);
        public static unsafe void first_person_reticule_style_hash(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x05B0, value);
        public static unsafe uint pickup_hash(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x05B4);
        public static unsafe void pickup_hash(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x05B4, value);
        public static unsafe uint mp_pickup_hash(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x05B8);
        public static unsafe void mp_pickup_hash(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x05B8, value);
        public static unsafe uint human_name_hash(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x05BC);
        public static unsafe void human_name_hash(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x05BC, value);
        public static unsafe uint audio_collision_hash(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x05C0);
        public static unsafe void audio_collision_hash(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x05C0, value);
        public static unsafe uint movement_mode_conditional_idle_hash(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x05C4);
        public static unsafe void movement_mode_conditional_idle_hash(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x05C4, value);
        public static unsafe byte ammo_diminishing_rate(byte* pWeaponInfo) => *(byte*) (pWeaponInfo + 0x05C8);
        public static unsafe void ammo_diminishing_rate(Mem64 mem, IntPtr addr, byte value) => mem.Write(addr + 0x05C8, value);
        public static unsafe sbyte hud_damage(byte* pWeaponInfo) => *(sbyte*) (pWeaponInfo + 0x05C9);
        public static unsafe void hud_damage(Mem64 mem, IntPtr addr, sbyte value) => mem.Write(addr + 0x05C9, value);
        public static unsafe sbyte hud_speed(byte* pWeaponInfo) => *(sbyte*) (pWeaponInfo + 0x05CA);
        public static unsafe void hud_speed(Mem64 mem, IntPtr addr, sbyte value) => mem.Write(addr + 0x05CA, value);
        public static unsafe sbyte hud_capacity(byte* pWeaponInfo) => *(sbyte*) (pWeaponInfo + 0x05CB);
        public static unsafe void hud_capacity(Mem64 mem, IntPtr addr, sbyte value) => mem.Write(addr + 0x05CB, value);
        public static unsafe sbyte hud_accuracy(byte* pWeaponInfo) => *(sbyte*) (pWeaponInfo + 0x05CC);
        public static unsafe void hud_accuracy(Mem64 mem, IntPtr addr, sbyte value) => mem.Write(addr + 0x05CC, value);
        public static unsafe sbyte hud_range(byte* pWeaponInfo) => *(sbyte*) (pWeaponInfo + 0x05CD);
        public static unsafe void hud_range(Mem64 mem, IntPtr addr, sbyte value) => mem.Write(addr + 0x05CD, value);
        public static unsafe float aiming_breathing_additive_weight(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x05D0);
        public static unsafe void aiming_breathing_additive_weight(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x05D0, value);
        public static unsafe float firing_breathing_additive_weight(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x05D4);
        public static unsafe void firing_breathing_additive_weight(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x05D4, value);
        public static unsafe float stealth_aiming_breathing_additive_weight(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x5D8);
        public static unsafe void stealth_aiming_breathing_additive_weight(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x5D8, value);
        public static unsafe float stealth_firing_breathing_additive_weight(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x5DC);
        public static unsafe void stealth_firing_breathing_additive_weight(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x5DC, value);
        public static unsafe float aiming_lean_additive_weight(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x05E0);
        public static unsafe void aiming_lean_additive_weight(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x05E0, value);
        public static unsafe float firing_lean_additive_weight(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x05E4);
        public static unsafe void firing_lean_additive_weight(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x05E4, value);
        public static unsafe float stealth_aiming_lean_additive_weight(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x05E8);
        public static unsafe void stealth_aiming_lean_additive_weight(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x05E8, value);
        public static unsafe float stealth_firing_lean_additive_weight(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x05EC);
        public static unsafe void stealth_firing_lean_additive_weight(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x05EC, value);
        public static unsafe int knockdown_count(byte* pWeaponInfo) => *(int*) (pWeaponInfo + 0x05F8);
        public static unsafe void knockdown_count(Mem64 mem, IntPtr addr, int value) => mem.Write(addr + 0x05F8, value);
        public static unsafe float killshot_impulse_scale(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x05FC);
        public static unsafe void killshot_impulse_scale(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x05FC, value);
        public static unsafe uint nm_shot_tuning_set_hash(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x0600);
        public static unsafe void nm_shot_tuning_set_hash(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x0600, value);
        public static unsafe int attach_point_count(byte* pWeaponInfo) => *(int*) (pWeaponInfo + 0x08f8);
        public static unsafe void attach_point_count(Mem64 mem, IntPtr addr, int value) => mem.Write(addr + 0x08f8, value);
        public static unsafe uint target_sequence_group_hash(byte* pWeaponInfo) => *(uint*) (pWeaponInfo + 0x0930);
        public static unsafe void target_sequence_group_hash(Mem64 mem, IntPtr addr, uint value) => mem.Write(addr + 0x0930, value);
        public static unsafe float bullet_direction_offset_in_degrees(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0934);
        public static unsafe void bullet_direction_offset_in_degrees(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0934, value);
        public static unsafe float bullet_direction_pitch_offset(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0938);
        public static unsafe void bullet_direction_pitch_offset(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0938, value);
        public static unsafe float bullet_direction_pitch_homing_offset(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x093C);
        public static unsafe void bullet_direction_pitch_homing_offset(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x093C, value);
        public static unsafe float expand_ped_capsule_radius(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0954);
        public static unsafe void expand_ped_capsule_radius(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0954, value);
        public static unsafe float vehicle_attack_angle(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0958);
        public static unsafe void vehicle_attack_angle(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0958, value);
        public static unsafe float torso_ik_angle_limit(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x095C);
        public static unsafe void torso_ik_angle_limit(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x095C, value);
        public static unsafe float melee_damage_multiplier(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0960);
        public static unsafe void melee_damage_multiplier(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0960, value);
        public static unsafe float melee_right_fist_target_health_damage_scaler(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0964);
        public static unsafe void melee_right_fist_target_health_damage_scaler(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0964, value);
        public static unsafe float airborne_aircraft_lock_on_multiplier(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x0968);
        public static unsafe void airborne_aircraft_lock_on_multiplier(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x0968, value);
        public static unsafe float armoured_vehicle_glass_damage_override(byte* pWeaponInfo) => *(float*) (pWeaponInfo + 0x096C);
        public static unsafe void armoured_vehicle_glass_damage_override(Mem64 mem, IntPtr addr, float value) => mem.Write(addr + 0x096C, value);
        public static unsafe ushort rotate_barrel_bone(byte* pWeaponInfo) => *(ushort*) (pWeaponInfo + 0x988);
        public static unsafe void rotate_barrel_bone(Mem64 mem, IntPtr addr, ushort value) => mem.Write(addr + 0x988, value);
        public static unsafe ushort rotate_barrel_bone2(byte* pWeaponInfo) => *(ushort*) (pWeaponInfo + 0x98A);
        public static unsafe void rotate_barrel_bone2(Mem64 mem, IntPtr addr, ushort value) => mem.Write(addr + 0x98A, value);
        
        public static unsafe char* stat_name; //0x05F0
    }
}